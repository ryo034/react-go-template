# フロントエンドとバックエンドの通信方法について

フロントエンドとバックエンドの通信方法について、各通信方法を比較検討し決定する

## Status

accepted

## Context

このプロジェクトにおいて、フロントエンドとバックエンドの通信において最も重要な要素は次の通り
- 高いパフォーマンスと低いレイテンシー
- 明確で型安全な通信プロトコル
- スキーマの書きやすさ

以下が通信方法の選択肢として存在する
- OpenAPI
- gPRC-Web
- GraphQL

||HTTPプロトコル|エンドポイント|パフォーマンス|データ型のサポート|
|-|-|-|-|-|
|REST API|HTTP/1.1、HTTP/2|リソースごとにエンドポイントが設けられることが多い。そのリソースに対する操作をGET, POST, PUT, DELETEなどで表現。|△(JSONであることや、オーバ/アンダーフェッチは起こり得る)|JSON、XML、MessagePackなど|
|gRPC|HTTP/2|サービスごとに.protoファイルで定義され、サービス内の各メソッドが実質的なエンドポイントとなる。|◯(ProtobufとHTTP/2により一般的に良い)|Protobuf|
|GraphQL|HTTP/1.1、HTTP/2|/graphqlの単一。一つのエンドポイントで全てのクエリとミューテーションを処理し、クライアントは具体的なデータ要求をクエリとして送信する|◯(クライアントがほしいデータを指定するので、オーバ/アンダーフェッチは起こりにくい)|型付けられたGraphQLのスキーマ|


### OpenAPI
#### Pros
- 一般的な採用例が多く、実装例や知見がWeb上に豊富に存在している
- クライアントからサーバーへの設計が一般的で直感的で実装しやすい
- キャッシュさせやすい

#### Cons
- OpenAPIを使用してスキーマを作成することもできるが、スキーマとの一貫性を保つためのサードパーティ製ライブラリが存在するなど、サポートには差がある印象。
- また、スキーマを書く体験がとても悪い。後述するprotoスキーマは個人的にはとても書きやすい。
- 以前利用した際に、生成されるコードのクラスの命名がとても使いづらかった

OpenAPIの柔軟性と広範なサポートは魅力的ですが、このプロジェクトではより高速な通信と明確な型定義の利点が優先したい

### gRPC-Web
[connect-go](https://connectrpc.com/docs/go/getting-started/)を利用することでgRPC、gRPC-Web、およびConnect独自のプロトコルの3つを最初からサポートしたサーバー、クライアントが作れる。
さらにプロキシは不要でConnect独自のプロトコルはREST APIになっていてcurlで簡単にテストすることが可能。

クライアント側からの通信では**gRPC-Web**を使用したい。なぜならPlaywrightで通信をMockすることができるからだ。

<details>

<summary>マイクロサービスを使うような場合</summary>

マイクロサービスを使うような場合は、クライアント側からの通信ではREST APIを使用したい。
なぜならPlaywrightで通信をMockすることができるからだ。

https://playwright.dev/docs/mock

具体的に、gRPC-WebをMockする方法を知らないので、Playwrightで簡単にMockできるRestを使用する。
</details>

以下理由からこちらを採用
- 私自身に知見が十分にあること
- gRPCでもプロキシが不要
- 型安全でスキーマファースト（スキーマの書き心地がとても良い）
- リアルタイム通信や大量のデータ通信を簡単に実装できる
- いざとなったらREST APIでも通信できる

### GraphQL

ちゃんと作れれば、APIは1つで済み実装コストは低くなると思うが、何より私の知見が少ない。
- キャッシュどうする問題
- N+1
- フェッチできるデータの制限
- 常200に対するエラーハンドリング
- 使用するフレームワーク
- 無限ループ

フロントエンド主体で作りたいケースで使用されると思うが、フロントエンドとバックエンドの両方を実装するので、特に考える必要はない。
これらの懸念について、解決には追加の学習と実装が必要であり、短期間の個人開発プロジェクトには適していないと判断しました。

これらを加味しても比較対象と比べて導入するメリットは少ないと思う。

## Decision

フロントエンドとバックエンドの通信方法はconnect-goを用いた**gRPC-Web**を使用する

## Consequences
